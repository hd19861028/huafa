/**
 * Git地址	：https://github.com/felixge/node-mysql
 * 作者		：胡锦柢
 * 时间		：2015-12-31 08:59
 * 描述		：pool添加error事件，用于重新创建连接池
 */
var mysql = require('mysql');
var pool = null;

var fs = require("fs");
var path = require("path");
var cache = require("./cache");
var q = require('./async').q;
var bling = require("bling-hashes");

exports = module.exports;

function getHash(str) {
	return bling.bkdr(str);
}

/**
 * @sql: 待查询的sql语句，支持多语句的配置，需要在config.json中定义
 * @params: 数组类型，依次传入sql语句中？定义的参数
 * @cache_key: 如需自动加入redis缓存，请为该次查询定义一个特殊的key
 * @returns: promise对象，resolve为成功，reject为失败，2者参数一致，都返回一个json对象，包含3个属性rows, sql, error
 */
exports.promise = function(sql, params, cache_key) {
	var db = null;
	var ckey = "";
	var d = q.defer();
	var pool_error_count = 0;
	var data = {};

	if (cache_key && global.config.cache.enable) {
		if (cache_key.indexOf('?')) cache_key = cache_key.split('?')[0];

		if (params && params.length >= 0) {
			for (var i = 0; i < params.length; i++) {
				if (params[i] != null && params[i] != undefined && params[i].toString() != "") {
					ckey += "_";
					if (params[i] === true)
						ckey += 1;
					else if (params[i] === false)
						ckey += 0;
					else
						ckey += params[i].toString();
				}
			}
		}
		ckey = cache_key + getHash(ckey);
	}

	var invoke = function() {
		get_con(function(conn) {
			db = conn;
			var options = get_options(sql);
			if (params)
				options.sql = db.format(options.sql, params);

			db.query(options, function(err, rows, fields) {
				if (err) {
					d.reject(err);
				} else {
					if (cache_key)
						cache.set(ckey, rows);
					data.rows = rows;
					data.sql = this.sql;
					d.resolve(data);
				}
				conn.release();
			});
		})
	}

	if (cache_key && global.config.cache.enable) {
		cache.exists(ckey, function(err, value) {
			if (value) {
				data.rows = value;
				data.sql = null;
				d.resolve(data);
			} else {
				invoke();
			}
		})
	} else {
		invoke();
	}

	return d.promise;
}

exports.query = function(sql, callback, params, cache_key) {
	var db = null;
	var ckey = "";
	var pool_error_count = 0;

	if (cache_key && global.config.cache.enable) {
		if (cache_key.indexOf('?')) cache_key = cache_key.split('?')[0];

		if (params && params.length >= 0) {
			for (var i = 0; i < params.length; i++) {
				if (params[i] != null && params[i] != undefined && params[i].toString() != "") {
					ckey += "_";
					if (params[i] === true)
						ckey += 1;
					else if (params[i] === false)
						ckey += 0;
					else
						ckey += params[i].toString();
				}
			}
		}
		ckey = cache_key + getHash(ckey);
	}

	var invoke = function() {
		get_con(function(conn) {
			db = conn;
			var options = get_options(sql);
			if (params)
				options.sql = db.format(options.sql, params);

			db.query(options, function(err, rows, fields) {
				if (err) {
					err.sql = this.sql;
					callback(null, err);
				} else {
					if (cache_key)
						cache.set(ckey, rows);

					callback(rows, null, this.sql);
				}
				conn.release();
			});
		});
	}

	if (cache_key && global.config.cache.enable) {
		cache.exists(ckey, function(err, value) {
			if (value) {
				callback(value, null);
			} else {
				invoke();
			}
		})
	} else {
		invoke();
	}
}

exports.transaction = function(sql_list, params_list, callback) {
	var trans = null;

	var querys = function(sql_list, params_list, callback) {
		var is_last = sql_list.length == 1 ? true : false;
		var options = get_options(sql_list.shift());
		var params = params_list.shift();
		trans.query(options, params, function(err, result) {
			if (err) {
				trans.rollback();
				callback(null, err);
			} else {
				if (is_last) {
					trans.commit(function(err) {
						if (err) {
							callback(null, err); //console.log(err);
						} else {
							callback(result, null); //console.log(result);
						}
					});
				} else {
					querys(sql_list, params_list, callback);
				}
			}
		});
	}

	var db = get_connection();
	init_tran(db, false);
	trans = db.startTransaction();
	if (sql_list.length >= 1) {
		querys(sql_list, params_list, callback);
		trans.execute();
	}
}

exports.sort = function(field) {
	return mysql.escapeId(field);
}

/**
 * 生产出sql查询条件
 * options是一个json对象
 * key：查询的字段
 * value：查询的类型(-2:小于等于, -1:小于, 0:等于, 1:大于, 2:大于等于, 3:like查询)
 * 函数返回值是一个string对象，如下示例
 * 		title like ? and age >= ? and size=?
 */
exports.filter_and = function(options) {
	var sql = " where ";
	Object.keys(options).forEach(function(key) {
		sql += exports.sort(key) + get_operator(options[key]);
	});
	sql = sql.substr(sql, sql.length - 4);

	return sql;
}

var get_con = function(cb) {
	if (!pool) {
		var db_config = global.config.db;
		pool = mysql.createPool(db_config);
		pool.on('error', function(err) {
			"mysql连接池发生错误".WriteLog();
			var db_config = global.config.db;
			pool = mysql.createPool(db_config);
		});
	}
	pool.getConnection(function(err, conn) {
		if (err) {
			err.WriteLog();
		} else {
			cb(conn);
		}
	});
}

function get_operator(type) {
	var operator = "";
	switch (type) {
		case -2:
			operator = "<=? and ";
			break;
		case -1:
			operator = "<? and ";
			break;
		case 0:
			operator = "=? and ";
			break;
		case 1:
			operator = ">? and ";
			break;
		case 2:
			operator = ">=? and ";
			break;
		case 3:
			operator = "like ? and ";
			break;
	}
	return operator;
}

exports.delete = function(ids, userid, table, callback) {
	ids = ids.indexOf(',') >= 0 ? ids.split(',') : new Array(ids);
	var id_params = "";
	for (var i = 0; i < ids.length; i++) {
		id_params += "?,";
	}
	id_params = id_params.substr(0, id_params.length - 1);
	var sql = "update " + table + " set isdeleted=1,updateuser=?,updatetime=? where id in (" + id_params + ") and id<>?";
	ids.push(userid)
	ids.unshift(new Date().getTime())
	ids.unshift(userid)
	exports.query(sql, callback, ids);
}

var get_connection = function(is_multiple) {
	var db_config = global.config.db;
	if (is_multiple == true) {
		db_config.multipleStatements = true;
	}
	var db = mysql.createConnection(db_config);
	return db;
}

var get_options = function(sql) {
	var db_config = global.config.db;
	var options = {
		timeout: db_config.timeout * 1000,
		sql: sql
	};
	return options;
}

function init_tran(db, debug) {
	if (debug !== true) debug = false;
	var options = {
		debug: debug,
		currentlyExecutingQueue: null,
		mainQueue: []
	};
	var dbQuery = db.query;

	db.query = function(sql, params, cb) {
		if (options.currentlyExecutingQueue == null)
			return dbQuery.apply(db, arguments);
		else
			options.mainQueue.push(arguments);
	}
	db.createQueue = function() {
		return new Queue(function() {
			return dbQuery.apply(db, arguments);
		}, function() {
			var ceq = options.currentlyExecutingQueue;
			if (ceq != null && ceq.commit != null) {
				if (ceq._autoCommit !== true)
					console.warn("The last query to run was:", ceq.lastExecuted.sql);
				ceq.commit(ceq._autoCommitCB);
				return;
			}
			options.currentlyExecutingQueue = null;
			while (options.mainQueue.length > 0) {
				var item = options.mainQueue.shift();
				if (item instanceof Queue) {
					item.execute();
					break;
				} else
					dbQuery.apply(db, item);
			}
		}, options);
	}
	db.startTransaction = function() {
		return Queue.isNowTransaction(this.createQueue(), function() {
			return dbQuery.apply(db, arguments);
		});
	}
}

function Queue(dbQuery, resumeMainQueue, options) {
	this.queue = [];
	this.paused = false;
	this.query = function(sql, params, cb) {
		if (typeof params == "function") {
			cb = params;
			params = undefined;
		}
		this.queue.push({
			'sql': sql,
			'params': params,
			'cb': cb
		});
		return this;
	};
	this.execute = function() {
		if (this.paused === true || this.executing) return;
		var that = this;
		if (options.currentlyExecutingQueue != null && options.currentlyExecutingQueue != this)
			options.mainQueue.push(this);
		else if (that.queue.length > 0) {
			options.currentlyExecutingQueue = this;
			that.executing = true;
			var done = 0,
				total = that.queue.length;
			for (var i = 0; i < total; i++) {
				(function(item) {
					try {
						if (item.sql == "COMMIT") delete that.rollback;
						that.lastExecuted = item;
						dbQuery(item.sql, item.params || [], function() {
							if (options.debug && arguments[0] != null)
								console.error("mysql-queues: An error occurred while executing the following " +
									"query:\n\t", item.sql);
							if (item.cb != null)
								item.cb.apply(this, arguments);
							if (++done == total) {
								that.executing = false;
								if (that.paused === true) return;
								if (that.queue.length == 0)
									resumeMainQueue();
								else
									that.execute();
							}
						});
					} catch (e) {
						if (options.debug)
							console.log("mysql-queues: An exception occurred for this query:\n\t",
								item.sql, "\twith parameters:\n\t", item.params);
						throw e;
					}
				})(that.queue[i]);
			}
			that.queue = [];
		} else if (options.currentlyExecutingQueue == this)
			resumeMainQueue();
		return this;
	};
	this.pause = function(maxWaitTime) {
		this.paused = true;
		if (maxWaitTime > 0) {
			var that = this;
			that.pauseTimer = setTimeout(function() {
				that.resume();
			}, maxWaitTime);
		}
		return this;
	}
	this.resume = function() {
		if (this.pauseTimer)
			clearTimeout(this.pauseTimer);
		this.paused = false;
		this.execute();
		return this;
	}
}

Queue.isNowTransaction = function(q, dbQuery) {
	q.query("START TRANSACTION");
	q.commit = function(cb) {
		if (this.queue.length > 0) {
			this._autoCommit = true;
			this._autoCommitCB = cb;
			this.resume();
		} else {
			delete this.commit;
			delete this._autoCommit;
			this.query("COMMIT", cb).resume();
		}
	}
	q.rollback = function(cb) {
		this.queue = [];
		delete this.commit;
		delete this.rollback;
		dbQuery("ROLLBACK", cb);
		this.resume();
	}
	return q;
}