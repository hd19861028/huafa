var fs = require("fs");
var path = require("path");
var uuid = require('node-uuid');
var querystring = require('querystring');
var net = require('net');
var crypto = require('crypto');
var db = require('./mysql');
var q = require('./async').q;
var expat = require('node-expat');

exports = module.exports;

exports.xml_to_json = function(xml, callback) {
	var json = {};
	var root_name = "";
	var node_name = "";
	var parser = new expat.Parser('UTF-8');
	parser.on('startElement', function(name, attrs) {
		if (node_name == "" && root_name == "") root_name = name;
		node_name = name;
	})

	parser.on('endElement', function(name) {
		if (name == root_name) {
			if (callback) callback(json)
		}
	})

	parser.on('text', function(text) {
		if (text && text != '\n') {
			json[node_name] = text;
		}
	})

	parser.on('error', function(error) {
		console.error(error)
	})

	parser.write(xml);
}

exports.guid = function() {
	return uuid.v4();
}

exports.get_ip = function(req) {
	var ips = req.headers['x-forwarded-for'];
	console.log(req.headers['x-real-ip'])
	console.log(ips)
	var ip = "";
	var index = ips.indexOf(',');
	if (index >= 0) {
		ip = ips.split(',')[0];
	} else {
		ip = ips;
	}
	return ip;
}
exports.make_pwd = function(pwd, callback) {
	pwd = !pwd ? "123456" : pwd;
	var salt = new Buffer(crypto.randomBytes(256)).toString('hex');
	crypto.pbkdf2(pwd, salt, 10000, 256, function(err, key) {
		if (err) {
			throw err;
		}
		var p = new Buffer(key).toString('hex');
		callback(salt, p);
	});
}

exports.make_pwd_promise = function(pwd) {
	var d = q.defer();
	pwd = !pwd ? "123456" : pwd;
	var salt = new Buffer(crypto.randomBytes(256)).toString('hex');
	crypto.pbkdf2(pwd, salt, 10000, 256, function(err, key) {
		if (err) {
			throw err;
		}
		var p = new Buffer(key).toString('hex');
		d.resolve({
			salt: salt,
			pwd: p
		})
	});
	return d.promise;
}

exports.valid_pwd_promise = function(pwd, pwd_db, salt) {
	var d = q.defer();

	crypto.pbkdf2(pwd, salt, 10000, 256, function(err, key) {
		if (err) {
			throw err;
		}
		var p = new Buffer(key).toString('hex');

		if (p == pwd_db) {
			d.resolve(true);
		} else {
			d.resolve(false);
		}
	});
	return d.promise;
}

exports.valid_pwd = function(pwd, pwd_db, salt, callback) {
	crypto.pbkdf2(pwd, salt, 10000, 256, function(err, key) {
		if (err) {
			throw err;
		}
		var p = new Buffer(key).toString('hex');
		if (p == pwd_db) {
			callback(true);
		} else {
			callback(false);
		}
	});
}

exports.ToFormatString = function(date, format) {
	var formatstr = format;
	if (format != null && format != "") {
		if (formatstr.indexOf("yyyy") >= 0) {
			formatstr = formatstr.replace("yyyy", date.getFullYear());
		}
		if (formatstr.indexOf("MM") >= 0) {
			var month = date.getMonth() + 1;
			if (month < 10) {
				month = "0" + month;
			}
			formatstr = formatstr.replace("MM", month);
		}
		if (formatstr.indexOf("dd") >= 0) {
			var day = date.getDate();
			if (day < 10) {
				day = "0" + day;
			}
			formatstr = formatstr.replace("dd", day);
		}
		var hours = date.getHours();
		if (formatstr.indexOf("HH") >= 0) {
			if (month < 10) {
				month = "0" + month;
			}
			formatstr = formatstr.replace("HH", hours);
		}
		if (formatstr.indexOf("hh") >= 0) {
			if (hours > 12) {
				hours = hours - 12;
			}
			if (hours < 10) {
				hours = "0" + hours;
			}
			formatstr = formatstr.replace("hh", hours);
		}
		if (formatstr.indexOf("mm") >= 0) {
			var minute = date.getMinutes();
			if (minute < 10) {
				minute = "0" + minute;
			}
			formatstr = formatstr.replace("mm", minute);
		}
		if (formatstr.indexOf("ss") >= 0) {
			var second = date.getSeconds();
			if (second < 10) {
				second = "0" + second;
			}
			formatstr = formatstr.replace("ss", second);
		}
	}
	return formatstr;
}

exports.try_connect = function(ip, port, cb) {
	var client = net.createConnection(port, ip);
	client.on('connect', function() {
		if (cb) cb(true);
	});
	client.on('error', function(err) {
		var msg = "can't to connect the " + ip + ":" + port;
		console.error(msg)
		throw new Error(msg);
	});
}

exports.str_to_bool = function(str, d) {
	if (!str) {
		if (!d) {
			return false;
		} else {
			return d;
		}
	} else if (str == 'false' || str == '0') {
		return false;
	} else {
		return true;
	}
}

exports.fromto_date_parse = function(str, isto) {
	if (str) {
		if (str.length > 10) {
			return Date.parse(str);
		} else {
			if (isto) {
				return Date.parse(str + " 23:59:59");
			} else {
				return Date.parse(str + " 00:00:00");
			}
		}
	} else {
		return null;
	}
};